
VALID_TOOLCHAINS := pnacl newlib glibc
CONFIG ?= Debug

include $(NACL_SDK_ROOT)/tools/common.mk

LOCAL_PATH := $(call my-dir)
NOT_ARM := 1
CPP_REC := 1
#NO_REND := 1
NO_NIXPROF := 1


RZDCY_SRC_DIR = ../../core

include $(RZDCY_SRC_DIR)/core.mk

TARGET = reicast
DEPS = nacl_io
LIBS = ppapi_gles2 ppapi_cpp ppapi pthread nacl_io

CFLAGS  = -Wno-error -Wno-ignored-attributes 
CFLAGS += -O3 -fno-strict-aliasing -ffast-math
CFLAGS += -I$(RZDCY_SRC_DIR) -I$(RZDCY_SRC_DIR)/deps
CFLAGS += -D RELEASE -D TARGET_NO_JIT -D TARGET_NACL32 -DGLES
CFLAGS += -D TARGET_NO_EXCEPTIONS -D TARGET_NO_NVMEM -D TARGET_NO_WEBUI -D TARGET_NO_COREIO_HTTP

SOURCES = $(RZDCY_FILES) ../../core/nacl/nacl.cpp

# Project Build flags
WARNINGS ?=-Wno-long-long -Wno-switch-enum
CXXFLAGS += -std=gnu++0x $(WARNINGS)


# Build rules generated by macros from common.mk:

$(foreach dep,$(DEPS),$(eval $(call DEPEND_RULE,$(dep))))

$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))

# The PNaCl workflow uses both an unstripped and finalized/stripped binary.
# On NaCl, only produce a stripped binary for Release configs (not Debug).
ifneq (,$(or $(findstring pnacl,$(TOOLCHAIN)),$(findstring Release,$(CONFIG))))
$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
else
$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
endif

SHELL = sh

$(eval $(call NMF_RULE,$(TARGET),))